#!/bin/bash

this=$(basename "$0")
BROWSER=$(which firefox)

# default settings
explain=false
verbose=true
run=true

# colors
RED="\033[0;31m"
YELLOW="\033[1;33m"
GREEN="\033[0;32m"
NO_COLOR="\033[0m"
BOLD="\033[1m"
UNDERLINE="\033[4m"

die() {
    echo -e "${RED}${@}${NO_COLOR}"
    exit 1
}

warn() {
    echo -e "${YELLOW}${@}${NO_COLOR}"
}

good() {
    echo -e "${GREEN}${@}${NO_COLOR}"
}

# Check commands
GIT=$(which git)
if [[ -z "$GIT" ]]; then
    die "git is not installed"
fi

SSH=$(which ssh)
if [[ -z "$SSH" ]]; then
    die "ssh is not installed"
fi

#GERRIT_CHERRY_PICK=$(which gerrit-cherry-pick)

#if [[ -z "$GERRIT_CHERRY_PICK" ]]; then
#    die "gerrit-cherry-pick is not installed"
#fi

# creates a new unique output file by using the current process ID
GIT_OUTPUT_FILE="/tmp/git_output$$"

GIT_DIR=$($GIT rev-parse --git-dir 2>/dev/null)

if [[ -z "$GIT_DIR" ]]; then
	if [ "$1" != "clone" ]&&[ "$1" != "update" ]&&[ "$1" != "-v" ];then
    	die "$this can only be run from a git repository."
	fi
fi

if [ "$1" != "clone" ]&&[ "$1" != "update" ]&&[ "$1" != "-v" ];then
	CURRENT=$($GIT symbolic-ref -q HEAD || $GIT rev-parse HEAD)
	CURRENT=${CURRENT#refs/heads/}
fi

git() {
    if [[ "$verbose" = true ]]; then
        echo -e "+ ${GREEN}git $@${NO_COLOR}"
    fi

    if [[ "$run" = true ]]; then
        $GIT $@ 2>&1 | tee /dev/tty > $GIT_OUTPUT_FILE
        return ${PIPESTATUS[0]}
    fi
}
gerrit-cherry-pick() {
    if [[ "$verbose" = true ]]; then
        echo -e "+ ${GREEN}gerrit-cherry-pick $@${NO_COLOR}"
    fi

    if [[ "$run" = true ]]; then
        $GERRIT_CHERRY_PICK $@ 2>&1 | tee /dev/tty > $GIT_OUTPUT_FILE
        return ${PIPESTATUS[0]}
    fi
}
ssh() {
    if [[ "$verbose" = true ]]; then
        echo -e "+ ${GREEN}ssh $@${NO_COLOR}"
    fi

    if [[ "$run" = true ]]; then
        $SSH $@ 2>&1 | tee /dev/tty > $GIT_OUTPUT_FILE
        return ${PIPESTATUS[0]}
    fi
}

trap _cleanup_git_output EXIT

_cleanup_git_output() {
    rm -f $GIT_OUTPUT_FILE
}

no_changes () {
    # $GIT diff-index --quiet --cached HEAD -- &&
    #     $GIT diff-files --quiet
    $GIT update-index --refresh --unmerged -q >/dev/null
    $GIT diff-index --quiet --cached HEAD -- &&
        $GIT diff-files --quiet
}

is_integer() {
    [[ "$1" = [0-9]* ]] > /dev/null 2>&1
    return $?
}

has_remote_branch() {
    local remote=$1 branch=$2
    $GIT branch -r | grep "$remote/$branch" > /dev/null
    return $?
}

is_review_branch() {
    local branch=$1
    if [[ "${branch:0:1}" = "r" ]]; then
        local change=${branch:1}
        if is_integer $change; then
            return 0
        fi
    fi
    return 1
}

ask_yes_no() {
    if [ "" = "$2" ] ; then
        local msg="$1 [y/n]: "
    else
        local msg="$1 (y/n) [$2]: "
    fi
    while true; do
        read -p "$msg" choice
            case ${choice:-$2} in
                y|Y|yes|Yes|YES)
                    return 0
                    ;;
                n|no|No|NO)
                    return 1
                    ;;
                *)
                    warn "Please choose either y or n"
                    ;;
            esac
    done
}

# gerrit track file.
GERRIT_TRACK="${GIT_DIR}/GERRIT_TRACK"

set_track() {
    local branch="$1" from_branch="$2" remote"$3" track="$4" track_commit="$5"

    remove_track "$branch"

    echo "$branch:$from_branch:$remote:$track:$track_commit" >> $GERRIT_TRACK
}

remove_track() {
    if [ ! -e "$GERRIT_TRACK" ] ; then
        return
    fi
    local branch="${1:-$CURRENT}"
    sed -i '' -e "/$branch:/d" "$GERRIT_TRACK"
}

get_change_number_from_branch() {
    if is_review_branch $CURRENT; then
        CHANGE=${CURRENT:1}
        if [[ $verbose = true ]]; then
            good "Using change number $CHANGE from branch name"
        fi
        return 0
    fi
    return 1
}

patch_count_for_change() {
    local change_id=$1
    local hash=$(($change_id % 100))
    case $hash in
        [0-9]) hash="0$hash" ;;
    esac

    $GIT ls-remote $REMOTE "refs/changes/$hash/$change_id/*" | \
        sed 's/.*\///g' | sort -n | tail -n1
}

getGerritServerAndProject() {
    if [ "" != "${host}" ] ; then
        return
    fi

    local host_and_project=$($GIT remote -v | grep push | awk '{print$2}')
    #local host_and_project=${url_line# *URL: }

    host=''
    project=''
    port=''

    if [[ "$host_and_project" =~ "ssh://" ]]; then
      local host_and_project=${host_and_project#ssh://}
      local host_and_port=${host_and_project%%/*}

      if [[ "$host_and_port" =~ ":" ]]; then
        host=${host_and_port%:*}
        port=${host_and_port#*:}
      else
        host=${host_and_port}
        port=""
      fi
      project=${host_and_project#*/}
    else
      host=${host_and_project%:*}
      project=${host_and_project#*:}
      port=""
    fi

    project=${project%.git}

    port=${port%/*}
    if [[ ! -z "$port" ]]; then
      port="-p $port"
    fi
}

executeGerritCommand() {
    getGerritServerAndProject
    gerrit_command_result=$($SSH $port $host gerrit $@)
}

getBranchInfo() {
    REMOTE=`$GIT config branch.$CURRENT.remote`

    if [[ -z "$REMOTE" ]]; then
        REMOTE=origin
    fi

    TRACK=`$GIT config branch.$CURRENT.merge`

    if [[ -n "$TRACK" ]]; then
        TRACK=${TRACK#refs/heads/}
        IS_TRACKING_REMOTE=y
    fi

    if [[ -e "$GERRIT_TRACK" ]]; then
        local data=($(fgrep "$CURRENT:" "$GERRIT_TRACK" | awk -F: '{print $2" "$3" "$4" "$5}'))
        if [[ -n "${data[0]}" ]] ; then
            FROM_BRANCH=${data[0]}
            REMOTE=${data[1]}
            TRACK=${data[2]}
            TRACK_COMMIT=${data[3]}
        fi
    fi

    if [[ -z "$TRACK" ]]; then
        TRACK=$CURRENT
    fi
    ORIG_TRACK=$TRACK
}

# git gerrit apply 100
applyChange() {
    abort_on_bad_repo_state

    local change=$CHANGE branch=r$CHANGE current="$CURRENT"
    local remote="$REMOTE" track="$TRACK"

    # IS_TRACKING_REMOTE
    if [[ -z "$IS_TRACKING_REMOTE" ]] ; then
        # not tracking remote, let's guess.
        if has_remote_branch $remote $current ; then
            track="$current"
        else
            local msg="Your may forget set upstream branch for branch ${GREEN}$current${RED}."
            local msg="${msg}\nSince the changes ${GREEN}$change${RED} must be applied on proper remote branch."
            local msg="${msg}\nType the following command to set:"
            local msg="${msg}\n${GREEN}git branch --set-upstream $current${RED} [upstream]."
            die $msg
        fi
    fi

    local track_branch="$remote/$track"

    # create a new branch based on the current tracking branch to work in
    $GIT branch -D $branch 2>/dev/null 1>&2
    git checkout -b $branch $track_branch ||
        die "Unable to create a new branch '$branch'"

    # track original branch.
    set_track $branch $current $remote $track "$($GIT rev-parse $track_branch)"

    # apply the change to the new branch
    local patch="$(patch_count_for_change $change)"
    gerrit-cherry-pick $remote $change/$patch ||
        die "Unable to apply ±$change/$patch on top of $track_branch"

    if [[ "$verbose" = true ]]; then
        good "Successfully cherry-picked ±$change so you can begin reviewing it"
    fi
}

# git gerrit reset
resetChange() {
    if [[ "$1" == "-f" ]]; then
        git reset --hard
    else
        abort_on_bad_repo_state
    fi

    local current="$CURRENT" from_branch="$FROM_BRANCH"
    local remote="$REMOTE" track="$TRACK" track_branch="$REMOTE/$TRACK"

    # clean up after gerrit-cherry-pick if it failed
    rm -rf "$GIT_DIR/rebase-gerrit"

    # clean up TRACK file
    remove_track "$current"

    if [[ ${CURRENT:0:1} == "r" ]] && is_integer ${CURRENT:1}; then
        git checkout $from_branch && git branch -D $current ||
            die "Unable to close the review branch $current"
    else
        die "We are not on a review branch ($current)"
    fi
}

updateChange() {
    if ! is_review_branch $CURRENT; then
        warn "$CURRENT is not a review branch"
        printUsage
        exit 2
    fi

    abort_on_bad_repo_state

    CHANGE=${CURRENT:1}
    resetChange
    TRACK="$ORIG_TRACK"
    CURRENT="$FROM_BRANCH"
    applyChange
}

showPatchSetDiff() {
    get_change_number_from_branch ||
        die "Unable to get change number from $CURRENT"

    local current="$CURRENT" from_branch="$FROM_BRANCH"
    local remote="$REMOTE" track="$TRACK" track_branch="$REMOTE/$TRACK"

    local params=($@)
    local params_len=${#params[@]}

    if [ "$params_len" -eq "0" ] ; then
        local params=($params HEAD)
    fi

    local commit=${params[${#params[@]}-1]}

    if [[ $commit = --* ]] ; then
        local commit=HEAD
    else
        unset params[${#params[@]}-1]
    fi

    local args="diff $params $track_branch..$commit"
    if [[ "$verbose" = true ]]; then
        echo -e "+ ${GREEN}git $args${NO_COLOR}"
    fi
    $GIT $args
}

diffPatches() {
    get_change_number_from_branch ||
        die "Unable to get change number from $CURRENT"

    local current="$CURRENT" from_branch="$FROM_BRANCH"
    local remote="$REMOTE" track="$TRACK" track_branch="$REMOTE/$TRACK"

    local change=$CHANGE
    local changeref=refs/remotes/changes/${change:(-2)}/$change

    case $# in
        0)
            local patch2=$(patch_count_for_change $change)
            local patch1=$((patch2 - 1))
            ;;
        1)
            local patch2=$(patch_count_for_change $change)
            local patch1=$1
            ;;
        2)
            local patch1=$1
            local patch2=$2
            ;;
        3)
            local change=$1
            local patch1=$2
            local patch2=$3
            ;;
        *)
            printShortUsage
            die "too many arguments"
            ;;
    esac

    if [[ "$patch1" = "$patch2" ]] || [[ "$patch1" = 0 ]]; then
        die "Only one patchset--nothing to diff!"
    fi

    if [[ "$verbose" = true ]]; then
        good "Diffing patchset $patch1 vs patchset $patch2"
    fi

    local branch1="r$change,$patch1"
    local branch2="r$change,$patch2"

    # create a branch for patch1
    git checkout -b $branch1 $track_branch >/dev/null 2>&1 ||
        die "Unable to create a new branch '$branch1'"
    gerrit-cherry-pick $remote $change/$patch1 >/dev/null 2>&1 ||
        die "Unable to apply ±$branch1 on top of $track_branch"

    # create a branch for patch2
    git checkout -b $branch2 $track_branch >/dev/null 2>&1 ||
        die "Unable to create a new branch '$branch2'"
    gerrit-cherry-pick $remote $change/$patch2 >/dev/null 2>&1 ||
        die "Unable to apply ±$branch2 on top of $track_branch"

    # actually show the diff
    git diff --src-prefix=$branch1: --dst-prefix=$branch2: --color $branch1 $branch2 > $GIT_OUTPUT_FILE
    less -rf $GIT_OUTPUT_FILE
    rm -f $GIT_OUTPUT_FILE

    git checkout "$CURRENT" >/dev/null 2>&1 ||
        die "Unable to switch back to $CURRENT"

    git branch -D $branch1 $branch2 >/dev/null 2>&1 ||
        die "Unable to delete temporary patch branches"
}

reviewChange() {
    if is_integer $CHANGE; then
        local PATCH=$(patch_count_for_change $CHANGE)
    else
        die "You must be on a review branch"
    fi

    getGerritServerAndProject

    local current="$CURRENT" from_branch="$FROM_BRANCH"
    local remote="$REMOTE" track="$TRACK" track_branch="$REMOTE/$TRACK"

    local LOG=$($GIT log --pretty="format:%s" $track_branch..HEAD)
    good "Reviewing '$LOG'..."

    local zero="0"

    read -e -p "Verified (-1..+1) [0] : " VERIFIED
    VERIFIED="${VERIFIED:-$zero}"
    read -e -p "Code review (-2..+2) [0] : " CODE_REVIEW
    CODE_REVIEW="${CODE_REVIEW:-$zero}"

    echo "You may supply a message. Hit return once your are done."
    read -e -p "Message: " MESSAGE

    local CMD="$host $port gerrit review"
    CMD="$CMD --verified=$VERIFIED"
    CMD="$CMD --code-review=$CODE_REVIEW"
    CMD="$CMD --project=$project $CHANGE,$PATCH"
    if [[ -n $MESSAGE ]]; then
        CMD="$CMD --message=\"$MESSAGE\""
    fi

    ssh $CMD

    # if ask_yes_no "Reset review branch?" "n"; then
    #     resetChange
    # fi
}

submitChange() {
    if is_integer $CHANGE; then
        local PATCH=$(patch_count_for_change $CHANGE)
    else
        die "You must be on a review branch"
    fi

    getGerritServerAndProject

    local current="$CURRENT" from_branch="$FROM_BRANCH"
    local remote="$REMOTE" track="$TRACK" track_branch="$REMOTE/$TRACK"

    local LOG=$($GIT log --pretty="format:%s" $track_branch..HEAD)
    good "Submiting '$LOG'..."

    echo "You may supply a message. Hit return once your are done."
    read -e -p "Message: " MESSAGE

    local CMD="$host $port gerrit review"
    CMD="$CMD --submit"
    CMD="$CMD --project=$project $CHANGE,$PATCH"
    if [[ -n $MESSAGE ]]; then
        CMD="$CMD --message=\"$MESSAGE\""
    fi

    ssh $CMD

    if ask_yes_no "Reset review branch?" "y"; then
        resetChange
    fi
}

abandonChange() {
    if is_integer $CHANGE; then
        local PATCH=$(patch_count_for_change $CHANGE)
    else
        die "You must be on a review branch"
    fi

    getGerritServerAndProject

    local current="$CURRENT" from_branch="$FROM_BRANCH"
    local remote="$REMOTE" track="$TRACK" track_branch="$REMOTE/$TRACK"

    local LOG=$($GIT log --pretty="format:%s" $track_branch..HEAD)
    good "Abandoning '$LOG'..."

    echo "You may supply a message. Hit return once your are done."
    read -e -p "Message: " MESSAGE

    local CMD="$host $port gerrit review"
    CMD="$CMD --abandon"
    CMD="$CMD --project=$project $CHANGE,$PATCH"
    if [[ -n $MESSAGE ]]; then
        CMD="$CMD --message=\"$MESSAGE\""
    fi

    ssh $CMD

    if ask_yes_no "Reset review branch?" "y"; then
        resetChange
    fi
}

# git gerrit push
pushCommit() {
    abort_on_bad_repo_state
	#最多支持两个参数
    local remote="$1" refs="$2" change="$CHANGE" current="$CURRENT" track
    local prompt_track=n
    local disable_reset_prompt=y

    # parse remote and refs parameters.
	#没有任何参数
    if [ -z "$remote" ] ; then
        prompt_track=y
        remote="$REMOTE"
        if [ -n "$CHANGE" ] ; then
            refs="refs/changes/$CHANGE"
        else
            refs="refs/for/$TRACK"
        fi
	#只有一个参数
    elif [ -z "$refs" ] ; then
        refs="$1"
        remote="$REMOTE"
    fi
	#重新审查refs远程分支是否正确
    if [[ $refs != refs/* ]] ; then
    	refs="refs/for/$refs"
	fi
    # parse the track and prompt message from refs.
    if [[ $refs == refs/changes/* ]] ; then
        track=$TRACK
        prompt_track=n
    else
        track="$(echo $TRACK | sed -e 's/refs\/[a-z]*\///')"
    fi

    if [ "$prompt_track" = "y" ] ; then
        read -e -p "Please enter a branch to push to [$track] : " choice
        track=${choice:-$track}
        refs="refs/for/$track"
        read -p "Optionally choose a topic [no topic]: " topic
    fi

    if [[ -n "$change" && "$refs" != "refs/changes/$change" ]] ; then
        die "You can only push to refs/changes/$change on review branch."
    fi

    if [[ -n "$change" ]] ; then
        # squash commits for submit change patch set.
        #$GIT branch -f "$current.head"
        local msg="$($GIT log --pretty=format:'%s%n%b%n%n' $remote/$track..HEAD)"

        $GIT reset --soft $remote/$track
        $GIT commit -m "$msg"
    else
        # pull --rebase to make sure pushed commit bases on correct parent.
        local msg="Unable to pull and rebase your branch $track to the $remote/$track."
        local msg="${msg}\nPlease resolve the pull issue and try again."
        git pull --rebase $remote || die "$msg"
    fi

    local log=$($GIT log --pretty="format:%s" $remote/$track..HEAD)
    local changesets=$($GIT rev-list $remote/$track..HEAD | wc -l)
    local changesets=${changesets//[[:space:]]}

    if [[ "$run" = true ]]; then
        if [[ "$changesets" = "0" ]]; then
            warn "You have no changes to review. Are you on the right branch?"
        elif [[ "$changesets" != "1" ]]; then
            warn "You have $changesets changes, but you should only push one at a time. Did you forget to squash your commits?"
            if ! ask_yes_no "Continue?" "y"; then
                die "Existing"
            fi
        fi
    fi

    local change_args="$remote HEAD:$refs"

    if [[ -n "$topic" ]]; then
        change_args="$change_args/$topic"
    fi
	local gerrit_reviewer=$($GIT config --global user.reviewer)
	test -z $gerrit_reviewer && warn "you can run \"git config --global user.reviewer YourReviewerEmail1,YourReviewerEmail2,YourReviewerEmail3\""
	if [[ -n $gerrit_reviewer ]]&&[ ! "$(echo "$change_args"|grep -o '%r=')" ];then
		change_args="$change_args%r=$gerrit_reviewer"
	fi
	#echo change_args=$change_args
	git push $change_args 
	local push_result=$?

    git_push_output=$(test -f $GIT_OUTPUT_FILE && cat $GIT_OUTPUT_FILE)
	
	if [ "${push_result}" == 1 ];then
		die Fail: $(echo $git_push_output |  grep -wo "(.*)" | tr -d "()"| head -n1)
	fi

    if [[ "$disable_reset_prompt" != "y" && -z "$change" && "$CURRENT" = "$track" ]] && ask_yes_no "Reset to $remote/$track?" "n"; then
        git reset --hard $remote/$track ||
        die "Could not reset your $track branch to $remote/$track."
    fi

    if [[ -n "$change" ]] ; then
        if  ask_yes_no "Update the review branch $track?" "y"; then
            updateChange ||
                die "Could not update your review branch $track."
        fi
        #$GIT branch -D "$current.head" 2>/dev/null
    fi

    if [[ "$run" = true ]]; then
        url=$(echo "$git_push_output" | grep http | head -n1)
        #if [[ -n "$url" ]]; then
            # if [[ -n "$BROWSER" ]]; then
            #     eval "$BROWSER $url"
            # fi
            #good $url
        #fi

        if [[ "$disable_reset_prompt" != "y" && "$current" = "$track" ]]; then
            good "Successfully pushed \n$log\n for review and reset $track"
        else
            good "\nSuccessfully pushed: \n$log"
        fi
    fi
}

mergeBranch() {
    git merge --squash "$1"

    if [ ! "$?" = 0 ] ; then
        die "You must type a exist branch or commit"
    fi

    # find the commits.
    if [ -e "${GIT_DIR}/SQUASH_MSG_" ] ; then
        rm "${GIT_DIR}/SQUASH_MSG_"
    fi

    head=$($GIT rev-parse HEAD)
    commits=$(fgrep "commit " "${GIT_DIR}/SQUASH_MSG" | awk '{print $2}')
    for commit in ${commits} ; do
        result=$($GIT cat-file commit $commit | grep "parent ${head}")
        if [ "" != "${result}" ] ; then
            break
        fi
    done

    while read line ; do
        result=$(echo ${line} | grep "commit ${commit}")
        if [ "" != "${result}" ] ; then
            break
        fi

        # ignore the Change-Id: line.
        result=$(echo ${line} | grep "Change-Id:")
        if [ "" != "${result}" ] ; then
            continue
        fi

        echo ${line} >> "${GIT_DIR}/SQUASH_MSG_"
    done < "${GIT_DIR}/SQUASH_MSG"

    mv "${GIT_DIR}/SQUASH_MSG_" "${GIT_DIR}/SQUASH_MSG"

    $GIT commit
}

abort_on_bad_repo_state() {
    if ! no_changes; then
        die "You have local changes. Please do something with them before using $this"
    fi
}

initGerrit() {
	local git_dir=$($GIT rev-parse --git-dir 2>/dev/null)
    local commit_hook="${git_dir}/hooks/commit-msg"
    local meitu_commit_hook="${git_dir}/hooks"

    #if [ -x "${commit_hook}" ] ; then
    #    echo "gerrit commit-msg hook works well."
    #    return
    #fi

	getGerritServerAndProject
	rm -rf ${meitu_commit_hook}/
	git clone ssh://${WHO}@${SERVER}:${PORT}/gerrit/hook ${meitu_commit_hook} || die "failed to add gerrit commit-msg hook."
	cp ${meitu_commit_hook}/git_hooks/*  ${meitu_commit_hook}/
	if [ -f ${meitu_commit_hook}/commit-msg ];then
		chmod +x "${commit_hook}"
    	echo "gerrit commit-msg hook setup correctly."
	else
		die "${meitu_commit_hook} don't found commit-msg!"
	fi
}

openChange() {
    local change="$CHANGE" user_change="$1" open_chagne="" ok=""

	if [ "$1" == "-h" ]||[ "$1" == "--help" ];then
		show_open_help
	fi

    if [[ -n "$user_change" ]] ; then
		open_change="$user_change"
	else
		show_open_help
    fi

    # get url from gerrit.
    getGerritServerAndProject
    executeGerritCommand "query" "project:${project}" "--commit-message=$open_change"

    url=$(echo "$gerrit_command_result" | grep http | head -n1 | awk '{print $2}')

    if [[ -n "$url" ]]; then
        if [[ -n "$BROWSER" ]]; then
            eval "$BROWSER $url" &>/dev/null  &
        fi
        good $url
    else
        warn "Could not find URL for change $open_change."
    fi
}

queryChanges() {
    local operators=$@
    if [ "" = "$1" ] ; then
        operators="status:open"
    fi
    getGerritServerAndProject
    executeGerritCommand "query" "--current-patch-set" "--all-approvals" "project:${project}" $operators
    echo "$gerrit_command_result" | less -FRSX
}

queryChangesDetail() {
    getGerritServerAndProject
    executeGerritCommand "query" "--current-patch-set" "--all-approvals" "--patch-sets" "change:'$1'" "project:${project}"
    echo "$gerrit_command_result" | less -FRSX
}


#### caicai ####

function show_clone_help(){
printf "Usage :
	$0 project branch download_dir
	project\t如果没有指定将会列举当前服务器上所有仓库
	branch\t如果没有指定将会列举当前仓库分支
	download_dir \t如果没有将默认使用仓库名作为下载文件夹名
\n"
exit 1
}

function show_open_help(){
printf "Usage :
	$0 open commit-id
	用于通过commit-id直接打开对应gerrit的review地址
\n"
exit 1
}

listProject(){
	local remote_project
	local count=0
	#good "for remote_project in $SSH -p $PORT ${WHO}@${SERVER} gerrit "ls-projects""
	for remote_project in $($SSH -p $PORT ${WHO}@${SERVER} gerrit "ls-projects")
	do
		if [ ! $(echo $remote_project | grep -E "gerrit|^All-" ) ];then
			echo -n "$count. "
			echo $remote_project
			PROJECTS[$count]=$remote_project
			((count++))
		fi
	done

}

listBranch(){
	local remote_branch
	local admin="gerrit"
	local count=0
	#good "for remote_branch in $SSH -p ${PORT} ${WHO}@${SERVER} gerrit ls-user-refs  --only-refs-heads -p ${alps_project} -u ${admin}|xargs -I [] basename []"
	for remote_branch in $($SSH -p ${PORT} ${WHO}@${SERVER} gerrit ls-user-refs  --only-refs-heads -p ${alps_project} -u ${admin}|xargs -I [] basename [])
	do
		#if [ ! $(echo $remote_branch| grep -E "modem|^All-|^teksun_" ) ];then
			echo -n "$count. "
			echo $remote_branch
			BRANCHS[$count]=$remote_branch
			((count++))
		#fi
	done

}

formatDownload(){
	local alps_project=$1
	local alps_branch=$2
	local download_dir=$3
	
	#good alps_project=${alps_project}
	#good alps_branch=${alps_branch}
	#good download_dir=${download_dir}
	
	#下载代码
	git clone ssh://${WHO}@${SERVER}:${PORT}/${alps_project} ${download_dir} -b ${alps_branch}
	
	#下载hooks代码
	cd ${download_dir}
	pwd
	initGerrit
	
	good "Download All Done!!"
}

cloneProject(){
	if [ "$1" == "-h" ]||[ "$1" == "--help" ];then
		show_clone_help
		exit 0
	fi
	declare -a PROJECTS
	declare -a BRANCHS
	local alps_project=$1
	local alps_branch=$2
	local download_dir=$3
	
	warn "Welcome Meitu Gerrit Code Downloads"
	
	if [ -z "${alps_project}" ];then
		listProject
		read -p "请选择你需要下载的仓库:[0] " answer
		if [ "${answer}" ];then
			alps_project=${PROJECTS[$answer]}
		else
			alps_project=${PROJECTS[0]}
		fi
	fi

	if [ -z "${alps_branch}" ];then
		listBranch
		read -p "请选择你需要下载的分支:[0] " answer
		if [ "${answer}" ];then
			alps_branch=${BRANCHS[$answer]}
		else
			alps_branch=${BRANCHS[0]}
		fi
	fi
	
	if [ -z "${download_dir}" ];then
		echo
		read -p "下载到本地文件夹:[${alps_project}] " answer
		if [ "${answer}" ];then
			download_dir=$answer
		else
			download_dir=${alps_project}
		fi
	fi

	formatDownload ${alps_project} ${alps_branch} ${download_dir}
}


updateScript(){
	local project="gerrit/git-gerrit"
	test -d ${project} && rm -rf ${project}
	git clone ssh://${WHO}@${SERVER}:${PORT}/${project} ${project} 1>/dev/null
	local RootDir=$(pwd)

	cd ${project}
	./install_local.sh 1>/dev/null
	cd $RootDir
	test -d ${project} && rm -rf $(dirname ${project})
	good "git-gerrit update success."

}
#强制更新函数
forceUpdate(){
	local keyword="git-gerrit script"
	#good "当前版本:${VERSION}"
	local server=$($SSH -p ${PORT} ${WHO}@${SERVER} gerrit ls-projects -d | grep "${keyword}" | sed -e "s/.*\(v.*\)/\1/g")
	#good 服务器版本:${server}
	local local=$VERSION
	#good 本地版本:${local}
	if [ "${local}" != "${server}" ];then
		good "${SCRIPT}版本有更新"
		$(which git-gerrit) update 
		local new_version=$($(which git-gerrit) -v)
		good "最新${new_version}"
		exit 0
	fi
}

#### caicai ####

#### usage ####
printShortUsage() {
    cat << EOF
   Options are: -e (explain) -v (verbose)
                -q (quite)   -h (help)
EOF
}
printUsage() {
    printShortUsage

    cat << EOF

OPTIONS
  -h  --help                  Show this message
  -v  --verbose               Show all commands before running them (default: on)
  -q  --quiet                 Don't display commands before running them (default: off)
  -e  --explain  --dry-run    Don't actually run commands (default: off)

DESCRIPTION
  $this assists in code reviews with gerrit, squashing merge local branch to gerrit branch,
  pushing or pulling changesets to review.

  init
    Init the gerrit hook.

EOF
}

#### now parse arguments ####

getBranchInfo
get_change_number_from_branch
SERVER="172.16.1.243"
PORT="29418"
VERSION="v1.0.2"
WHO=$($GIT config --global user.name)
test -z $WHO && die "please set username , you can run \"git config -global user.name yourGerritName\""

forceUpdate

while true; do
    arg=$1
    shift
    test -z "$arg" && break;

    case $arg in
        -e | --explain | --dry-run)
            echo "$this: using explain-only mode"
            explain=true
            verbose=true
            run=false
            ;;
        --verbose)
            verbose=true
            ;;
		-v | --version)
			good "${VERSION}"
			exit
			;;
        -q | --quiet)
            verbose=false
            ;;
        -h | --help | help)
            printUsage
            exit
            ;;
        merge)
            mergeBranch $1
            exit
            ;;
        commit)
            addCommit $@
            exit
            ;;
        push)
            pushCommit $@
            exit
            ;;
        init)
            initGerrit
            exit
            ;;
        open)
            openChange $@
            exit
            ;;
        changes)
            if is_integer $1; then
                queryChangesDetail $1
            else
                queryChanges $@
            fi
            exit
            ;;
        apply)
            if is_integer $1; then
                CHANGE=$1
            else
                if [[ -n $1 ]]; then
                    die "The change number must be an integer."
                fi
            fi
            applyChange
            exit
            ;;
        reset)
            if [[ -n $1 ]] && [[ $1 != "-f" ]]; then
                die "Only -f may be use as an argument for reset"
            fi
            resetChange $1
            exit
            ;;
        patchset)
            showPatchSetDiff $@
            exit
            ;;
        diff)
            diffPatches $1 $2 $3
            exit
            ;;
        rebase)
            if is_integer $1; then
                CHANGE=$1
            else
                if [[ -n $1 ]]; then
                    die "The change number must be an integer."
                fi
            fi
            rebaseChange
            exit
            ;;
        review)
			CHANGE=$1
            reviewChange
            exit
            ;;
        clone)
            cloneProject $1 $2 $3
            exit
            ;;
        update)
            updateScript
            exit
            ;;
        *)
            warn "$this: unrecognized option or subcommand $arg"
            printUsage
            exit 2
            ;;
    esac
done

# no subcommand given
printShortUsage
exit 2
