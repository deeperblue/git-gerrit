#!/bin/bash
this=$(basename "$0")
BROWSER=$(which firefox)

# default settings
explain=false
verbose=true
run=true

# colors
RED="\033[0;31m"
YELLOW="\033[1;33m"
GREEN="\033[0;32m"
NO_COLOR="\033[0m"
BOLD="\033[1m"
UNDERLINE="\033[4m"

die() {
    echo -e "${RED}${@}${NO_COLOR}"
    exit 1
}

warn() {
    echo -e "${YELLOW}${@}${NO_COLOR}"
}

good() {
    echo -e "${GREEN}${@}${NO_COLOR}"
}

# Check commands
GIT=$(which git)
if [[ -z "$GIT" ]]; then
    die "git is not installed"
fi

SSH=$(which ssh)
if [[ -z "$SSH" ]]; then
    die "ssh is not installed"
fi

#GERRIT_CHERRY_PICK=$(which gerrit-cherry-pick)

#if [[ -z "$GERRIT_CHERRY_PICK" ]]; then
#    die "gerrit-cherry-pick is not installed"
#fi

# creates a new unique output file by using the current process ID
GIT_OUTPUT_FILE="/tmp/git_output$$"

GIT_DIR=$($GIT rev-parse --git-dir 2>/dev/null)

if [[ -z "$GIT_DIR" ]]; then
	if [ "$1" != "clone" ]&&[ "$1" != "update" ]&&[ "$1" != "-v" ];then
    	die "$this can only be run from a git repository."
	fi
fi

if [[ "$1" != "clone" && "$1" != "update" && "$1" != "-v" ]];then
	CURRENT=$($GIT symbolic-ref -q HEAD || $GIT rev-parse HEAD)
	CURRENT=${CURRENT#refs/heads/}
fi

git() {
    if [[ "$verbose" = true ]]; then
        echo -e "+ ${GREEN}git $@${NO_COLOR}"
    fi

    if [[ "$run" = true ]]; then
        $GIT $@ 2>&1 | tee /dev/tty > $GIT_OUTPUT_FILE
        return ${PIPESTATUS[0]}
    fi
}
gerrit-cherry-pick() {
    if [[ "$verbose" = true ]]; then
        echo -e "+ ${GREEN}gerrit-cherry-pick $@${NO_COLOR}"
    fi

    if [[ "$run" = true ]]; then
        $GERRIT_CHERRY_PICK $@ 2>&1 | tee /dev/tty > $GIT_OUTPUT_FILE
        return ${PIPESTATUS[0]}
    fi
}
ssh() {
    if [[ "$verbose" = true ]]; then
        echo -e "+ ${GREEN}ssh $@${NO_COLOR}"
    fi

    if [[ "$run" = true ]]; then
        $SSH $@ 2>&1 | tee /dev/tty > $GIT_OUTPUT_FILE
        return ${PIPESTATUS[0]}
    fi
}

trap _cleanup_git_output EXIT

_cleanup_git_output() {
    rm -f $GIT_OUTPUT_FILE
}

no_changes () {
    # $GIT diff-index --quiet --cached HEAD -- &&
    #     $GIT diff-files --quiet
    $GIT update-index --refresh --unmerged -q >/dev/null
    $GIT diff-index --quiet --cached HEAD -- &&
        $GIT diff-files --quiet
}

is_integer() {
    [[ "$1" = [0-9]* ]] > /dev/null 2>&1
    return $?
}

has_remote_branch() {
    local remote=$1 branch=$2
    $GIT branch -r | grep "$remote/$branch" > /dev/null
    return $?
}

is_review_branch() {
    local branch=$1
    if [[ "${branch:0:1}" = "r" ]]; then
        local change=${branch:1}
        if is_integer $change; then
            return 0
        fi
    fi
    return 1
}

ask_yes_no() {
    if [ "" = "$2" ] ; then
        local msg="$1 [y/n]: "
    else
        local msg="$1 (y/n) [$2]: "
    fi
    while true; do
        read -p "$msg" choice
            case ${choice:-$2} in
                y|Y|yes|Yes|YES)
                    return 0
                    ;;
                n|no|No|NO)
                    return 1
                    ;;
                *)
                    warn "Please choose either y or n"
                    ;;
            esac
    done
}

# gerrit track file.
GERRIT_TRACK="${GIT_DIR}/GERRIT_TRACK"

set_track() {
    local branch="$1" from_branch="$2" remote"$3" track="$4" track_commit="$5"

    remove_track "$branch"

    echo "$branch:$from_branch:$remote:$track:$track_commit" >> $GERRIT_TRACK
}

remove_track() {
    if [ ! -e "$GERRIT_TRACK" ] ; then
        return
    fi
    local branch="${1:-$CURRENT}"
    sed -i '' -e "/$branch:/d" "$GERRIT_TRACK"
}

get_change_number_from_branch() {
    if is_review_branch $CURRENT; then
        CHANGE=${CURRENT:1}
        if [[ $verbose = true ]]; then
            good "Using change number $CHANGE from branch name"
        fi
        return 0
    fi
    return 1
}

patch_count_for_change() {
    local change_id=$1
    local hash=$(($change_id % 100))
    case $hash in
        [0-9]) hash="0$hash" ;;
    esac

    $GIT ls-remote $REMOTE "refs/changes/$hash/$change_id/*" | \
        sed 's/.*\///g' | sort -n | tail -n1
}

getGerritServerAndProject() {
    if [ "" != "${host}" ] ; then
        return
    fi

    local host_and_project=$($GIT remote -v | grep push | awk '{print$2}')
    #local host_and_project=${url_line# *URL: }

    host=''
    project=''
    port=''

    if [[ "$host_and_project" =~ "ssh://" ]]; then
      local host_and_project=${host_and_project#ssh://}
      local host_and_port=${host_and_project%%/*}

      if [[ "$host_and_port" =~ ":" ]]; then
        host=${host_and_port%:*}
        port=${host_and_port#*:}
      else
        host=${host_and_port}
        port=""
      fi
      project=${host_and_project#*/}
    else
      host=${host_and_project%:*}
      project=${host_and_project#*:}
      port=""
    fi

    project=${project%.git}

    port=${port%/*}
    if [[ ! -z "$port" ]]; then
      port="-p $port"
    fi
}

executeGerritCommand() {
    getGerritServerAndProject
    gerrit_command_result=$($SSH $port $host gerrit $@)
}

getBranchInfo() {
    REMOTE=`$GIT config branch.$CURRENT.remote`

    if [[ -z "$REMOTE" ]]; then
        REMOTE=origin
    fi

    TRACK=`$GIT config branch.$CURRENT.merge`

    if [[ -n "$TRACK" ]]; then
        TRACK=${TRACK#refs/heads/}
        IS_TRACKING_REMOTE=y
    fi

    if [[ -e "$GERRIT_TRACK" ]]; then
        local data=($(fgrep "$CURRENT:" "$GERRIT_TRACK" | awk -F: '{print $2" "$3" "$4" "$5}'))
        if [[ -n "${data[0]}" ]] ; then
            FROM_BRANCH=${data[0]}
            REMOTE=${data[1]}
            TRACK=${data[2]}
            TRACK_COMMIT=${data[3]}
        fi
    fi

    if [[ -z "$TRACK" ]]; then
        TRACK=$CURRENT
    fi
    ORIG_TRACK=$TRACK
}

# git gerrit apply 100
applyChange() {
    abort_on_bad_repo_state

    local change=$CHANGE branch=r$CHANGE current="$CURRENT"
    local remote="$REMOTE" track="$TRACK"

    # IS_TRACKING_REMOTE
    if [[ -z "$IS_TRACKING_REMOTE" ]] ; then
        # not tracking remote, let's guess.
        if has_remote_branch $remote $current ; then
            track="$current"
        else
            local msg="Your may forget set upstream branch for branch ${GREEN}$current${RED}."
            local msg="${msg}\nSince the changes ${GREEN}$change${RED} must be applied on proper remote branch."
            local msg="${msg}\nType the following command to set:"
            local msg="${msg}\n${GREEN}git branch --set-upstream $current${RED} [upstream]."
            die $msg
        fi
    fi

    local track_branch="$remote/$track"

    # create a new branch based on the current tracking branch to work in
    $GIT branch -D $branch 2>/dev/null 1>&2
    git checkout -b $branch $track_branch ||
        die "Unable to create a new branch '$branch'"

    # track original branch.
    set_track $branch $current $remote $track "$($GIT rev-parse $track_branch)"

    # apply the change to the new branch
    local patch="$(patch_count_for_change $change)"
    gerrit-cherry-pick $remote $change/$patch ||
        die "Unable to apply ±$change/$patch on top of $track_branch"

    if [[ "$verbose" = true ]]; then
        good "Successfully cherry-picked ±$change so you can begin reviewing it"
    fi
}

# git gerrit reset
resetChange() {
    if [[ "$1" == "-f" ]]; then
        git reset --hard
    else
        abort_on_bad_repo_state
    fi

    local current="$CURRENT" from_branch="$FROM_BRANCH"
    local remote="$REMOTE" track="$TRACK" track_branch="$REMOTE/$TRACK"

    # clean up after gerrit-cherry-pick if it failed
    rm -rf "$GIT_DIR/rebase-gerrit"

    # clean up TRACK file
    remove_track "$current"

    if [[ ${CURRENT:0:1} == "r" ]] && is_integer ${CURRENT:1}; then
        git checkout $from_branch && git branch -D $current ||
            die "Unable to close the review branch $current"
    else
        die "We are not on a review branch ($current)"
    fi
}

updateChange() {
    if ! is_review_branch $CURRENT; then
        warn "$CURRENT is not a review branch"
        printUsage
        exit 2
    fi

    abort_on_bad_repo_state

    CHANGE=${CURRENT:1}
    resetChange
    TRACK="$ORIG_TRACK"
    CURRENT="$FROM_BRANCH"
    applyChange
}

showPatchSetDiff() {
    get_change_number_from_branch ||
        die "Unable to get change number from $CURRENT"

    local current="$CURRENT" from_branch="$FROM_BRANCH"
    local remote="$REMOTE" track="$TRACK" track_branch="$REMOTE/$TRACK"

    local params=($@)
    local params_len=${#params[@]}

    if [ "$params_len" -eq "0" ] ; then
        local params=($params HEAD)
    fi

    local commit=${params[${#params[@]}-1]}

    if [[ $commit = --* ]] ; then
        local commit=HEAD
    else
        unset params[${#params[@]}-1]
    fi

    local args="diff $params $track_branch..$commit"
    if [[ "$verbose" = true ]]; then
        echo -e "+ ${GREEN}git $args${NO_COLOR}"
    fi
    $GIT $args
}

diffPatches() {
    get_change_number_from_branch ||
        die "Unable to get change number from $CURRENT"

    local current="$CURRENT" from_branch="$FROM_BRANCH"
    local remote="$REMOTE" track="$TRACK" track_branch="$REMOTE/$TRACK"

    local change=$CHANGE
    local changeref=refs/remotes/changes/${change:(-2)}/$change

    case $# in
        0)
            local patch2=$(patch_count_for_change $change)
            local patch1=$((patch2 - 1))
            ;;
        1)
            local patch2=$(patch_count_for_change $change)
            local patch1=$1
            ;;
        2)
            local patch1=$1
            local patch2=$2
            ;;
        3)
            local change=$1
            local patch1=$2
            local patch2=$3
            ;;
        *)
            printUsage
            die "too many arguments"
            ;;
    esac

    if [[ "$patch1" = "$patch2" ]] || [[ "$patch1" = 0 ]]; then
        die "Only one patchset--nothing to diff!"
    fi

    if [[ "$verbose" = true ]]; then
        good "Diffing patchset $patch1 vs patchset $patch2"
    fi

    local branch1="r$change,$patch1"
    local branch2="r$change,$patch2"

    # create a branch for patch1
    git checkout -b $branch1 $track_branch >/dev/null 2>&1 ||
        die "Unable to create a new branch '$branch1'"
    gerrit-cherry-pick $remote $change/$patch1 >/dev/null 2>&1 ||
        die "Unable to apply ±$branch1 on top of $track_branch"

    # create a branch for patch2
    git checkout -b $branch2 $track_branch >/dev/null 2>&1 ||
        die "Unable to create a new branch '$branch2'"
    gerrit-cherry-pick $remote $change/$patch2 >/dev/null 2>&1 ||
        die "Unable to apply ±$branch2 on top of $track_branch"

    # actually show the diff
    git diff --src-prefix=$branch1: --dst-prefix=$branch2: --color $branch1 $branch2 > $GIT_OUTPUT_FILE
    less -rf $GIT_OUTPUT_FILE
    rm -f $GIT_OUTPUT_FILE

    git checkout "$CURRENT" >/dev/null 2>&1 ||
        die "Unable to switch back to $CURRENT"

    git branch -D $branch1 $branch2 >/dev/null 2>&1 ||
        die "Unable to delete temporary patch branches"
}

reviewChange() {
    if is_integer $CHANGE; then
        local PATCH=$(patch_count_for_change $CHANGE)
    else
        die "You must be on a review branch"
    fi

    getGerritServerAndProject

    local current="$CURRENT" from_branch="$FROM_BRANCH"
    local remote="$REMOTE" track="$TRACK" track_branch="$REMOTE/$TRACK"

    local LOG=$($GIT log --pretty="format:%s" $track_branch..HEAD)
    good "Reviewing '$LOG'..."

    local zero="0"

    read -e -p "Verified (-1..+1) [0] : " VERIFIED
    VERIFIED="${VERIFIED:-$zero}"
    read -e -p "Code review (-2..+2) [0] : " CODE_REVIEW
    CODE_REVIEW="${CODE_REVIEW:-$zero}"

    echo "You may supply a message. Hit return once your are done."
    read -e -p "Message: " MESSAGE

    local CMD="$host $port gerrit review"
    CMD="$CMD --verified=$VERIFIED"
    CMD="$CMD --code-review=$CODE_REVIEW"
    CMD="$CMD --project=$project $CHANGE,$PATCH"
    if [[ -n $MESSAGE ]]; then
        CMD="$CMD --message=\"$MESSAGE\""
    fi

    ssh $CMD

    # if ask_yes_no "Reset review branch?" "n"; then
    #     resetChange
    # fi
}

submitChange() {
    if is_integer $CHANGE; then
        local PATCH=$(patch_count_for_change $CHANGE)
    else
        die "You must be on a review branch"
    fi

    getGerritServerAndProject

    local current="$CURRENT" from_branch="$FROM_BRANCH"
    local remote="$REMOTE" track="$TRACK" track_branch="$REMOTE/$TRACK"

    local LOG=$($GIT log --pretty="format:%s" $track_branch..HEAD)
    good "Submiting '$LOG'..."

    echo "You may supply a message. Hit return once your are done."
    read -e -p "Message: " MESSAGE

    local CMD="$host $port gerrit review"
    CMD="$CMD --submit"
    CMD="$CMD --project=$project $CHANGE,$PATCH"
    if [[ -n $MESSAGE ]]; then
        CMD="$CMD --message=\"$MESSAGE\""
    fi

    ssh $CMD

    if ask_yes_no "Reset review branch?" "y"; then
        resetChange
    fi
}

abandonChange() {
    if is_integer $CHANGE; then
        local PATCH=$(patch_count_for_change $CHANGE)
    else
        die "You must be on a review branch"
    fi

    getGerritServerAndProject

    local current="$CURRENT" from_branch="$FROM_BRANCH"
    local remote="$REMOTE" track="$TRACK" track_branch="$REMOTE/$TRACK"

    local LOG=$($GIT log --pretty="format:%s" $track_branch..HEAD)
    good "Abandoning '$LOG'..."

    echo "You may supply a message. Hit return once your are done."
    read -e -p "Message: " MESSAGE

    local CMD="$host $port gerrit review"
    CMD="$CMD --abandon"
    CMD="$CMD --project=$project $CHANGE,$PATCH"
    if [[ -n $MESSAGE ]]; then
        CMD="$CMD --message=\"$MESSAGE\""
    fi

    ssh $CMD

    if ask_yes_no "Reset review branch?" "y"; then
        resetChange
    fi
}

# git gerrit push
pushCommit() {
	if [ "$1" == "-h" ]||[ "$1" == "--help" ];then
		show_push_help
	fi
    abort_on_bad_repo_state
	#最多支持两个参数
    local remote="$1" refs="$2" change="$CHANGE" current="$CURRENT" track
    local prompt_track=n
    local disable_reset_prompt=y

    # parse remote and refs parameters.
	#没有任何参数
    if [ -z "$remote" ] ; then
        prompt_track=y
        remote="$REMOTE"
        if [ -n "$CHANGE" ] ; then
            refs="refs/changes/$CHANGE"
        else
            refs="refs/for/$TRACK"
        fi
	#只有一个参数
    elif [ -z "$refs" ] ; then
        refs="$1"
        remote="$REMOTE"
    fi
	#重新审查refs远程分支是否正确
    if [[ $refs != refs/* ]] ; then
    	refs="refs/for/$refs"
	fi
    # parse the track and prompt message from refs.
    if [[ $refs == refs/changes/* ]] ; then
        track=$TRACK
        prompt_track=n
    else
        track="$(echo $TRACK | sed -e 's/refs\/[a-z]*\///')"
    fi

    if [ "$prompt_track" = "y" ] ; then
        read -e -p "Please enter a branch to push to [$track] : " choice
        track=${choice:-$track}
        refs="refs/for/$track"
        read -p "Optionally choose a topic [no topic]: " topic
    fi

    if [[ -n "$change" && "$refs" != "refs/changes/$change" ]] ; then
        die "You can only push to refs/changes/$change on review branch."
    fi

    if [[ -n "$change" ]] ; then
        # squash commits for submit change patch set.
        #$GIT branch -f "$current.head"
        local msg="$($GIT log --pretty=format:'%s%n%b%n%n' $remote/$track..HEAD)"

        $GIT reset --soft $remote/$track
        $GIT commit -m "$msg"
    else
        # pull --rebase to make sure pushed commit bases on correct parent.
        local msg="Unable to pull and rebase your branch $track to the $remote/$track."
        local msg="${msg}\nPlease resolve the pull issue and try again."
        git pull --rebase $remote || die "$msg"
    fi

    local log=$($GIT log --pretty="format:%s" $remote/$track..HEAD)
    local changesets=$($GIT rev-list $remote/$track..HEAD | wc -l)
    local changesets=${changesets//[[:space:]]}

    if [[ "$run" = true ]]; then
        if [[ "$changesets" = "0" ]]; then
            warn "You have no changes to review. Are you on the right branch?"
        elif [[ "$changesets" != "1" ]]; then
            warn "You have $changesets changes, but you should only push one at a time. Did you forget to squash your commits?"
            if ! ask_yes_no "Continue?" "y"; then
                die "Existing"
            fi
        fi
    fi

    local change_args="$remote HEAD:$refs"

    if [[ -n "$topic" ]]; then
        change_args="$change_args/$topic"
    fi
	local gerrit_reviewer=$($GIT config --global user.reviewer)
	test -z $gerrit_reviewer && warn "you can run \"git config --global user.reviewer YourReviewerEmail1,YourReviewerEmail2,YourReviewerEmail3\""
	if [[ -n $gerrit_reviewer ]]&&[ ! "$(echo "$change_args"|grep -o '%r=')" ];then
		change_args="$change_args%r=$gerrit_reviewer"
	fi
	#echo change_args=$change_args
	git push $change_args 
	local push_result=$?

    git_push_output=$(test -f $GIT_OUTPUT_FILE && cat $GIT_OUTPUT_FILE)
	
	if [ "${push_result}" == 1 ];then
		die Fail: $(echo $git_push_output |  grep -wo "(.*)" | tr -d "()"| head -n1)
	fi

    if [[ "$disable_reset_prompt" != "y" && -z "$change" && "$CURRENT" = "$track" ]] && ask_yes_no "Reset to $remote/$track?" "n"; then
        git reset --hard $remote/$track ||
        die "Could not reset your $track branch to $remote/$track."
    fi

    if [[ -n "$change" ]] ; then
        if  ask_yes_no "Update the review branch $track?" "y"; then
            updateChange ||
                die "Could not update your review branch $track."
        fi
        #$GIT branch -D "$current.head" 2>/dev/null
    fi

    if [[ "$run" = true ]]; then
        url=$(echo "$git_push_output" | grep http | head -n1)
        #if [[ -n "$url" ]]; then
            # if [[ -n "$BROWSER" ]]; then
            #     eval "$BROWSER $url"
            # fi
            #good $url
        #fi

        if [[ "$disable_reset_prompt" != "y" && "$current" = "$track" ]]; then
            good "Successfully pushed \n$log\n for review and reset $track"
        else
            good "\nSuccessfully pushed: \n$log"
        fi
    fi
}

mergeBranch() {
    git merge --squash "$1"

    if [ ! "$?" = 0 ] ; then
        die "You must type a exist branch or commit"
    fi

    # find the commits.
    if [ -e "${GIT_DIR}/SQUASH_MSG_" ] ; then
        rm "${GIT_DIR}/SQUASH_MSG_"
    fi

    head=$($GIT rev-parse HEAD)
    commits=$(fgrep "commit " "${GIT_DIR}/SQUASH_MSG" | awk '{print $2}')
    for commit in ${commits} ; do
        result=$($GIT cat-file commit $commit | grep "parent ${head}")
        if [ "" != "${result}" ] ; then
            break
        fi
    done

    while read line ; do
        result=$(echo ${line} | grep "commit ${commit}")
        if [ "" != "${result}" ] ; then
            break
        fi

        # ignore the Change-Id: line.
        result=$(echo ${line} | grep "Change-Id:")
        if [ "" != "${result}" ] ; then
            continue
        fi

        echo ${line} >> "${GIT_DIR}/SQUASH_MSG_"
    done < "${GIT_DIR}/SQUASH_MSG"

    mv "${GIT_DIR}/SQUASH_MSG_" "${GIT_DIR}/SQUASH_MSG"

    $GIT commit
}

abort_on_bad_repo_state() {
    if ! no_changes; then
        die "You have local changes. Please do something with them before using $this"
    fi
}

initGerrit() {
	if [ "$1" == "-h" ]||[ "$1" == "--help" ];then
		show_init_help
	fi
	local git_dir=$($GIT rev-parse --git-dir 2>/dev/null)
    local commit_hook="${git_dir}/hooks/commit-msg"
    local meitu_commit_hook="${git_dir}/hooks"

    #if [ -x "${commit_hook}" ] ; then
    #    echo "gerrit commit-msg hook works well."
    #    return
    #fi

	getGerritServerAndProject
	rm -rf ${meitu_commit_hook}/
	git clone ssh://${WHO}@${SERVER}:${PORT}/gerrit/hook ${meitu_commit_hook} || die "failed to add gerrit commit-msg hook."
	cp ${meitu_commit_hook}/git_hooks/*  ${meitu_commit_hook}/
	if [ -f ${meitu_commit_hook}/commit-msg ];then
		chmod +x "${commit_hook}"
    	echo "gerrit commit-msg hook setup correctly."
	else
		die "${meitu_commit_hook} don't found commit-msg!"
	fi
}

openChange() {
    local change="$CHANGE" user_change="$1" open_chagne="" ok=""

	if [ "$1" == "-h" ]||[ "$1" == "--help" ];then
		show_open_help
	fi

    if [[ -n "$user_change" ]] ; then
		open_change="$user_change"
	else
		show_open_help
    fi

    # get url from gerrit.
    getGerritServerAndProject
    executeGerritCommand "query" "project:${project}" "--commit-message=$open_change"

    url=$(echo "$gerrit_command_result" | grep http | head -n1 | awk '{print $2}')

    if [[ -n "$url" ]]; then
        if [[ -n "$BROWSER" ]]; then
            eval "$BROWSER $url" &>/dev/null  &
        fi
        good $url
    else
        warn "Could not find URL for change $open_change."
    fi
}

queryChanges() {
    local operators=$@
    if [ "" = "$1" ] ; then
        operators="status:open"
    fi
    getGerritServerAndProject
    executeGerritCommand "query" "--current-patch-set" "--all-approvals" "project:${project}" $operators
    echo "$gerrit_command_result" | less -FRSX
}

queryChangesDetail() {
    getGerritServerAndProject
    executeGerritCommand "query" "--current-patch-set" "--all-approvals" "--patch-sets" "change:'$1'" "project:${project}"
    echo "$gerrit_command_result" | less -FRSX
}


#### caicai ####

show_clone_help(){
printf "Usage :
	${this} project branch download_dir
	project\t如果没有指定将会列举当前服务器上所有仓库
	branch\t如果没有指定将会列举当前仓库分支
	download_dir \t如果没有将默认使用仓库名作为下载文件夹名
\n"
exit 1
}

show_open_help(){
printf "Usage :
	${this} open commit-id
	用于通过commit-id直接打开对应gerrit的review地址
\n"
exit 1
}

show_init_help(){
printf "Usage :
	${this} init
	gerrit要求代码提交需要有对应的Change-Id作为唯一标示
	代码仓库第一次下载后需要下载对应的hooks脚本来生成对应Change-Id
\n"
exit 1
}
#Add by csy1@meitu.com begin,intergrate git-get cmd
show_get_help(){
printf "Usage :
	${this} get commit-id path
	用于提取某笔commit信息对应的修改文件和修改前文件，提取目录为new和old文件夹，保持文件目录树和前后修改对应点，方便meios功能移植对比合入修改点；

	commit-id：对应需要提取的commit-id
	path：可选参数，默认上一级的../path目录

	/home/user/patch/[CHG]commit-msg
	├── 0001-CHG.patch
	├── new
	│   └── packages
	└── old
	    └── packages

\n"
exit 1
}
#Add intergrate git-get cmd end
show_push_help(){
printf "Usage :
	${this} push
	1.先后提交入库顺序导致冲突:
		a) 在本地再次执行git-gerrit push,重新fetch服务器最新代码
		b) 本地代码将会download冲突下来，本地代码会提示冲突
		c) 本地解决冲突后，执行git rebase --continue
		d) 再次执行git-gerrit push重新上传解决冲突后的代码

	2.代码提交不规范或者有待完善，被打回:
		a)一次提交5条，第三条需要重新patchset
		b)本地执行git rebase -i HEAD~4，修改提交pick的表头为edit，让代码回退到第三条，分支处于nobranch缓冲区
		c)对应修改代码后，git add最新修改到暂存区，执行git commit --amend将最新更新合并到第三条提交
		d)执行git rebase --continue恢复环境
		e)重新执行git-gerrit push上传最新修改代码
Tip :
	gerrit以change-id作为commit提交的唯一标识码，所以在处理冲突的commit提交或者需要更新修改的commit，只需要保持change-id与之前一致，gerrit就不会产生新的提交。
\n"
exit 1
}

listProject(){
	local remote_project
	local count=0
	#good "for remote_project in $SSH -p $PORT ${WHO}@${SERVER} gerrit "ls-projects""
	for remote_project in $($SSH -p $PORT ${WHO}@${SERVER} gerrit "ls-projects")
	do
		if [ ! $(echo $remote_project | grep -E "gerrit|^All-" ) ];then
			echo -n "$count. "
			echo $remote_project
			PROJECTS[$count]=$remote_project
			((count++))
		fi
	done

}

listBranch(){
	local remote_branch
	local admin="gerrit"
	local count=0
	#good "for remote_branch in $SSH -p ${PORT} ${WHO}@${SERVER} gerrit ls-user-refs  --only-refs-heads -p ${alps_project} -u ${admin}|xargs -I [] basename []"
	for remote_branch in $($SSH -p ${PORT} ${WHO}@${SERVER} gerrit ls-user-refs  --only-refs-heads -p ${alps_project} -u ${admin}|xargs -I [] basename [])
	do
		#if [ ! $(echo $remote_branch| grep -E "modem|^All-|^teksun_" ) ];then
			echo -n "$count. "
			echo $remote_branch
			BRANCHS[$count]=$remote_branch
			((count++))
		#fi
	done

}

formatDownload(){
	local alps_project=$1
	local alps_branch=$2
	local download_dir=$3
	
	#good alps_project=${alps_project}
	#good alps_branch=${alps_branch}
	#good download_dir=${download_dir}
	
	#下载代码
	git clone ssh://${WHO}@${SERVER}:${PORT}/${alps_project} ${download_dir} -b ${alps_branch}
	
	#下载hooks代码
	cd ${download_dir}
	pwd
	initGerrit
	
	good "Download All Done!!"
}

cloneProject(){
	if [ "$1" == "-h" ]||[ "$1" == "--help" ];then
		show_clone_help
		exit 0
	fi
	declare -a PROJECTS
	declare -a BRANCHS
	local alps_project=$1
	local alps_branch=$2
	local download_dir=$3
	
	warn "Welcome Meitu Gerrit Code Downloads"
	
	if [ -z "${alps_project}" ];then
		listProject
		read -p "请选择你需要下载的仓库:[0] " answer
		if [ "${answer}" ];then
			alps_project=${PROJECTS[$answer]}
		else
			alps_project=${PROJECTS[0]}
		fi
	fi

	if [ -z "${alps_branch}" ];then
		listBranch
		read -p "请选择你需要下载的分支:[0] " answer
		if [ "${answer}" ];then
			alps_branch=${BRANCHS[$answer]}
		else
			alps_branch=${BRANCHS[0]}
		fi
	fi
	
	if [ -z "${download_dir}" ];then
		echo
		read -p "下载到本地文件夹:[${alps_project}] " answer
		if [ "${answer}" ];then
			download_dir=$answer
		else
			download_dir=${alps_project}
		fi
	fi

	formatDownload ${alps_project} ${alps_branch} ${download_dir}
}


updateScript(){
	local project="gerrit/git-gerrit"
	test -d ${project} && rm -rf ${project}
	git clone ssh://${WHO}@${SERVER}:${PORT}/${project} ${project} 1>/dev/null
	local RootDir=$(pwd)

	cd ${project}
	./install_local.sh 1>/dev/null
	cd $RootDir
	test -d ${project} && rm -rf $(dirname ${project})
	good "git-gerrit update success."

}
#强制更新函数
forceUpdate(){
	local keyword="git-gerrit script"
	#good "当前版本:${VERSION}"
	local server=$($SSH -p ${PORT} ${WHO}@${SERVER} gerrit ls-projects -d | grep "${keyword}" | sed -e "s/.*\(v.*\)/\1/g")
	#good 服务器版本:${server}
	local local=$VERSION
	#good 本地版本:${local}
	if [ "${local}" != "${server}" ];then
		good "${SCRIPT}版本有更新"
		updateScript 
		local new_version=$($(which git-gerrit) -v)
		good "最新${new_version}"
		exit 0
	fi
}

#Add by zhangbin@meitu.com begin,intergrate git-dfout cmd
function git_dfout()
{
    local OUT_PUT_DIR="../"
    while getopts "o:" arg #选项后面的冒号表示该选项需要参数
    do
        case $arg in
            o)
                if [ "x$OPTARG" != "x" ] ; then
                    OUT_PUT_DIR=$OPTARG	
                fi
                ;;

            ?) #当有不认识的选项的时候arg为?
                shell_err "unkonw argument"
                exit 
                ;;
        esac
    done
    
    local dirname="${OUT_PUT_DIR}/diff_$(${GIT} describe | tr -d '\n')_$(date +%Y%m%d_%H%M)"
    mkdir -p ${dirname}/old/  ${dirname}/new/

    ${GIT} status -s | while read f    
    do        
        if [ $(echo $f | awk '{ print $1 }') != "??" ];then        
            ${GIT} archive HEAD $(echo $f | awk '{ print $2 }') | tar -xf - -C ${dirname}/old/
        fi            
        
        if [ $(echo $f | awk '{ print $1 }') != "D" ];then        
            cp -af --parents $(echo $f | awk '{ print $2 }') ${dirname}/new/
        fi
    done
    
    echo "Success save diff_file in ${dirname}"    
}

#Only for cherry-pick fast review, It's a spm tools...
function fast_review()
{
    current_branch_name=$(${GIT} branch | grep "*" | awk '{print $2}')
    SUBMIT_LIST=""
    echo "${GIT} rev-list \"$(${GIT} config branch.${current_branch_name}.remote)/$(basename $(${GIT} config branch.${current_branch_name}.merge))..HEAD\""
    for cm in $(${GIT} rev-list "$(${GIT} config branch.${current_branch_name}.remote)/$(basename $(${GIT} config branch.${current_branch_name}.merge))..HEAD")
    do
        echo "ssh -p 29418 172.16.1.243 gerrit review --code-review 2 $cm"
        ssh -p 29418 172.16.1.243 gerrit review --code-review 2 $cm
        if [ $? != 0 ];then 
        echo "review faild."
            exit
        fi
        SUBMIT_LIST="${cm} ${SUBMIT_LIST}"
    done

    for s in ${SUBMIT_LIST}
    do
        echo "ssh -p 29418 172.16.1.243 gerrit review -s $s"
        ssh -p 29418 172.16.1.243 gerrit review -s $s
        if [ $? != 0 ];then
            echo "submit faild."
            exit
        fi
    done
}
#Add end

#### caicai ####
#Add by csy1@meitu.com begin,intergrate git-get cmd
function git_get(){
	if [ "$1" == "-h" ]||[ "$1" == "--help" ];then
		show_get_help
	fi
    #输出文件夹名称
    local originDir="old";
    local modifyDir="new";
    #取参
    local commitId=$1;
    local rootdir=$(pwd);
    local path=$2;
    test -z ${commitId} && commitId=$(${GIT} rev-parse --verify HEAD);
    test -z $path && path="../patch";
    #创建输出文件夹
    local name=$(${GIT} log -1 $1 --format=%s| sed "s# ##g"| tr ":" "-");
    path=$path/${name};
    cd $(${GIT} rev-parse --show-toplevel);
    #判断commit-id，输出文件
    for file in $(${GIT} show ${commitId} --format=%n --name-only  );
    do
        good "$file";
        #输出当前commit-id对应文件
        test -d ${path}/${modifyDir}/$(dirname $file) || mkdir -p ${path}/${modifyDir}/$(dirname $file);
        ${GIT} show ${commitId}:$file > ${path}/${modifyDir}/$file;
        #查找当前文件上一条状态
        local status=$(${GIT} show  --format=%n  ${commitId} --name-status ${file} | awk -F" " '{print$1}');
        if [ "$(echo "${status}" | grep -ow M)" == "M" ]; then
            #fix由于merge信息可能导致上一条commit-id无法查找的错误
            #fix由于short commit id值导致显示错误
            if [ "$(echo ${commitId} | wc -L)" -le "7" ]; then
                local last_commit_id=$(${GIT} log  --format=%h  ${file} | grep ${commitId} -1 |tail -1);
            else
                local last_commit_id=$(${GIT} log  --format=%H  ${file} | grep ${commitId} -1 |tail -1);
            fi;
            #输出上个版本文件
            test -d ${path}/${originDir}/$(dirname $file) || mkdir -p ${path}/${originDir}/$(dirname $file);
            ${GIT} show ${last_commit_id}:${file} > ${path}/${originDir}/$file;
        fi;
    done;
    #生成标注patch'文件备用
    ${GIT} format-patch -1 ${commitId} -o ${path} >/dev/null;
    cd - > /dev/null;
    good "patch补丁文件保存到 ${path}";

}
#Add intergrate git-get cmd end

#### usage ####
printUsage() {
cat << EOF
Usage: ${this} [options] actions

Options :  	
	--help			: 显示帮助
	--verbose		: 显示运行命令Log (default: on)
	--quiet			: 不显示运行命令Log (default: off)
	--explain		: 只显示Log，不运行命令 (default: off)
	

Actions :
	init  			: 初始化git仓库的hooks脚本 
	clone 			: 下载当前服务器代码
	open  			: 打开对应commit-id的review页面
	push  			: 提交代码到服务器
	update			: 脚本更新指令
	get			: 输出对应commit-id的原始/修改文件
	dfout 			: 输出当前修改的原始/修改文件

Example :
	${this} push 
				: 提交当前分支代码到服务器分支，交互式指令提交
	${this} push master
				: 提交当前分支修改到服务器master分支
	${this} clone 
				: 下载服务器代码仓库，不带参数情况下，交互式提示
	${this} clone MT6797/AndroidN master downloadDir
				: 下载MT6797 android的master分支代码到本地downloadDir文件夹
	${this} open commit-id
				: firefox打开commit-id对应的gerrit review界面
	${this} init 
				: 初始化当前git仓库，下载hooks脚本到当前仓库
	${this} update 
				: ${this}脚本升级指令
	${this} dfout 
				: 输出当前修改的原始/修改文件  -o参数输出目录(不带-o参数默认输出到上一级目录) 
	${this} get  commit-id
				: 输出对应commit-id的原始/修改文件 (默认输出路径../patch)
	${this} get  commit-id path
				: 输出对应commit-id的原始/修改文件 commit-id为目标commit id值，path为输出文件夹
				
                
Other ：
	1.脚本运行默认会检查版本是否有更新
	2.clone命令下载代码后，默认会执行init操作
	3.push的时候本地不能有未commit修改，push前会先pull --rebase最新代码
	4.${this} [actions] --help显示每个指令详细说明

version :${VERSION}
EOF
}
#### now parse arguments ####

getBranchInfo
get_change_number_from_branch
SERVER="172.16.1.243"
PORT="29418"
VERSION="v1.0.8"
WHO=$($GIT config --global gerrit.name)
test -z $WHO && die "please set your Gerrit username , you can run \"git config --global gerrit.name yourGerritName\""

forceUpdate

while true; do
    arg=$1
    shift
    test -z "$arg" && break;

    case $arg in
        -e | --explain | --dry-run)
            echo "$this: using explain-only mode"
            explain=true
            verbose=true
            run=false
            ;;
        --verbose)
            verbose=true
            ;;
		-v | --version)
			good "${VERSION}"
			exit
			;;
        -q | --quiet)
            verbose=false
            ;;
        -h | --help | help)
            printUsage
            exit
            ;;
        merge)
            mergeBranch $1
            exit
            ;;
        commit)
            addCommit $@
            exit
            ;;
        push)
            pushCommit $@
            exit
            ;;
        init)
            initGerrit $@
            exit
            ;;
        open)
            openChange $@
            exit
            ;;
        changes)
            if is_integer $1; then
                queryChangesDetail $1
            else
                queryChanges $@
            fi
            exit
            ;;
        apply)
            if is_integer $1; then
                CHANGE=$1
            else
                if [[ -n $1 ]]; then
                    die "The change number must be an integer."
                fi
            fi
            applyChange
            exit
            ;;
        reset)
            if [[ -n $1 ]] && [[ $1 != "-f" ]]; then
                die "Only -f may be use as an argument for reset"
            fi
            resetChange $1
            exit
            ;;
        patchset)
            showPatchSetDiff $@
            exit
            ;;
        diff)
            diffPatches $1 $2 $3
            exit
            ;;
        rebase)
            if is_integer $1; then
                CHANGE=$1
            else
                if [[ -n $1 ]]; then
                    die "The change number must be an integer."
                fi
            fi
            rebaseChange
            exit
            ;;
        review)
			CHANGE=$1
            reviewChange
            exit
            ;;
        clone)
            cloneProject $1 $2 $3
            exit
            ;;
        update)
            updateScript
            exit
            ;;
        dfout)
            git_dfout $@
            exit
            ;;
        get)
            git_get $@
            exit
            ;;
        autore)
            fast_review $@
            exit
            ;;        
            
        *)
            warn "$this: unrecognized option or subcommand $arg"
            printUsage
            exit 2
            ;;
    esac
done

# no subcommand given
printUsage
exit 2
